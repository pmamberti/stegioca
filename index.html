<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stegioca</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #fff;
      color: #000;
      font-family: 'Courier New', monospace;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    .screen { display: none; flex-direction: column; align-items: center; gap: 20px; width: 100%; max-width: 700px; padding: 20px; }
    .screen.active { display: flex; }
    h1, h2 { text-align: center; letter-spacing: 2px; }
    .card-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; width: 100%; }
    .card {
      border: 2px solid #ccc;
      padding: 12px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      transition: border-color 0.15s;
    }
    .card:hover { border-color: #666; }
    .card.selected { border-color: #000; border-width: 3px; }
    .card canvas { image-rendering: pixelated; image-rendering: crisp-edges; width: 128px; height: 128px; }
    .card .name { font-size: 14px; font-weight: bold; }
    .card .race-tag { font-size: 11px; padding: 2px 6px; border: 1px solid #999; text-transform: uppercase; letter-spacing: 1px; }
    .bottom-bar { display: flex; justify-content: space-between; align-items: center; width: 100%; margin-top: 16px; }
    button {
      background: #000;
      color: #fff;
      border: none;
      padding: 10px 24px;
      font-family: inherit;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    button:disabled { opacity: 0.3; cursor: not-allowed; }
    .waiting-cards { display: flex; gap: 24px; justify-content: center; }
    .blink { animation: blink 1s step-end infinite; }
    @keyframes blink { 50% { opacity: 0; } }
    #result-heading { font-size: 28px; }
    #result-narrative { max-width: 500px; text-align: center; line-height: 1.6; }
    .title { font-size: 10px; letter-spacing: 8px; opacity: 0.4; text-transform: uppercase; }
  </style>
</head>
<body>
  <div id="screen-selection" class="screen active">
    <div class="title">STEGIOCA</div>
    <h1>CHOOSE YOUR TEAM</h1>
    <div id="card-grid" class="card-grid">
      <!-- 6 cards injected by JS -->
    </div>
    <div class="bottom-bar">
      <span id="selection-counter">0 / 2 selected</span>
      <button id="btn-start" disabled>START MISSION</button>
    </div>
  </div>

  <div id="screen-waiting" class="screen">
    <h1>MISSION IN PROGRESS</h1>
    <div id="waiting-cards" class="waiting-cards">
      <!-- 2 selected cards shown here -->
    </div>
    <p id="waiting-text" class="blink">...</p>
  </div>

  <div id="screen-result" class="screen">
    <h2 id="result-heading"></h2>
    <div id="result-cards" class="waiting-cards"></div>
    <p id="result-narrative"></p>
    <button id="btn-new-mission">NEW MISSION</button>
  </div>

  <script>
// ── Seeded RNG (mulberry32) ──
function createRNG(seed) {
  return function() {
    seed |= 0; seed = seed + 0x6D2B79F5 | 0;
    let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

// ── Name Generation ──
const NAME_SYLLABLES = {
  Human:     { first: ['dev','en','dra','mar','co','li','sa','jon','ray','el','ka','ri'],
               last:  ['ray','sol','kirk','vale','cross','stone','ward','finn'] },
  Tharn:     { first: ['grok','thur','brak','gor','kru','dag','vol','ruk','mog','zar'],
               last:  ['nash','gul','dok','mar','thok','gar','bur'] },
  Cephalid:  { first: ['zyl','thu','pho','gla','cthu','nyl','rhy','vos','qua','mur'],
               last:  ['ath','oth','ull','yth','esh','arn','ix'] },
  Gravborn:  { first: ['bor','ked','sten','dol','grun','tor','hal','vik','mag','rek'],
               last:  ['ax','ven','dig','holm','pit','ore','shaft'] },
  Insectoid: { first: ['zik','chi','kri','bzz','tik','xer','cli','vri','ski','phi'],
               last:  ['xis','tak','rik','zzt','kis','thi','nik'] },
  Construct: { first: ['MK','AX','SR','TX','VK','NX','RX','BX','CX','ZR'],
               last:  ['7','13','99','42','08','31','66','0','77','51'] },
};

function generateName(race, rng) {
  const s = NAME_SYLLABLES[race];
  const first = s.first[Math.floor(rng() * s.first.length)];
  const last = s.last[Math.floor(rng() * s.last.length)];
  if (race === 'Construct') return first + '-' + last;
  return first.charAt(0).toUpperCase() + first.slice(1) + ' ' + last.charAt(0).toUpperCase() + last.slice(1);
}

// ── Drawing Primitives ──
function setPixel(pixels, size, x, y, val) {
  if (x >= 0 && x < size && y >= 0 && y < size) {
    pixels[y * size + x] = val;
  }
}

function fillRect(pixels, size, x, y, w, h, val) {
  for (let dy = 0; dy < h; dy++) {
    for (let dx = 0; dx < w; dx++) {
      setPixel(pixels, size, x + dx, y + dy, val);
    }
  }
}

function fillEllipse(pixels, size, cx, cy, rx, ry, val) {
  for (let dy = -ry; dy <= ry; dy++) {
    for (let dx = -rx; dx <= rx; dx++) {
      if ((dx * dx) / (rx * rx) + (dy * dy) / (ry * ry) <= 1.0) {
        setPixel(pixels, size, cx + dx, cy + dy, val);
      }
    }
  }
}

function hLine(pixels, size, x1, x2, y, val) {
  const start = Math.min(x1, x2);
  const end = Math.max(x1, x2);
  for (let x = start; x <= end; x++) {
    setPixel(pixels, size, x, y, val);
  }
}

function vLine(pixels, size, x, y1, y2, val) {
  const start = Math.min(y1, y2);
  const end = Math.max(y1, y2);
  for (let y = start; y <= end; y++) {
    setPixel(pixels, size, x, y, val);
  }
}

// Draw a filled triangle (flat-bottom or flat-top via 3 points)
function fillTriangle(pixels, size, x0, y0, x1, y1, x2, y2, val) {
  const minY = Math.min(y0, y1, y2);
  const maxY = Math.max(y0, y1, y2);
  for (let y = minY; y <= maxY; y++) {
    let minX = size, maxX = 0;
    const edges = [[x0,y0,x1,y1],[x1,y1,x2,y2],[x2,y2,x0,y0]];
    for (const [ax, ay, bx, by] of edges) {
      if ((ay <= y && by >= y) || (by <= y && ay >= y)) {
        const dy = by - ay;
        const x = dy === 0 ? Math.min(ax, bx) : ax + (y - ay) * (bx - ax) / dy;
        minX = Math.min(minX, Math.floor(x));
        maxX = Math.max(maxX, Math.ceil(x));
      }
    }
    for (let x = minX; x <= maxX; x++) {
      setPixel(pixels, size, x, y, val);
    }
  }
}

// Draw a circle outline
function circleOutline(pixels, size, cx, cy, r, val) {
  for (let a = 0; a < 360; a++) {
    const rad = a * Math.PI / 180;
    const x = Math.round(cx + r * Math.cos(rad));
    const y = Math.round(cy + r * Math.sin(rad));
    setPixel(pixels, size, x, y, val);
  }
}

// Draw an ellipse outline
function ellipseOutline(pixels, size, cx, cy, rx, ry, val) {
  const steps = Math.max(rx, ry) * 8;
  for (let i = 0; i < steps; i++) {
    const a = (i / steps) * Math.PI * 2;
    const x = Math.round(cx + rx * Math.cos(a));
    const y = Math.round(cy + ry * Math.sin(a));
    setPixel(pixels, size, x, y, val);
  }
}

// ── Race Drawers ──
// All drawing uses full 128-wide coordinates, centered at x=64.
// No symmetry mirror — each side is drawn explicitly with natural asymmetry.
// val=1 means filled (foreground), val=0 means cleared (background).

const RACE_DRAWERS = {

  // ════════════════════════════════════════════
  //  HUMAN
  // ════════════════════════════════════════════
  Human: {
    drawBody(pixels, size, rng) {
      const cx = 64;
      const shoulderTop = 66;
      const shoulderW = 60; // half-width from center
      // Fill main torso block
      fillRect(pixels, size, cx - shoulderW, shoulderTop + 6, shoulderW * 2, size - shoulderTop - 6, 1);
      // Shoulder slopes (both sides)
      for (let i = 0; i < 8; i++) {
        const w = Math.floor(shoulderW * (i + 1) / 8);
        hLine(pixels, size, cx - w, cx + w, shoulderTop + i, 1);
      }
      // Jacket collar V-shape — both sides
      for (let i = 0; i < 6; i++) {
        setPixel(pixels, size, cx - i, shoulderTop + 4 + i, 0);
        setPixel(pixels, size, cx + i, shoulderTop + 4 + i, 0);
        if (i > 0) {
          setPixel(pixels, size, cx - i + 1, shoulderTop + 4 + i, 0);
          setPixel(pixels, size, cx + i - 1, shoulderTop + 4 + i, 0);
        }
      }
      // Lapel lines — left and right
      for (let i = 0; i < 10; i++) {
        setPixel(pixels, size, cx - 6 - Math.floor(i / 4), shoulderTop + 10 + i, 0);
        setPixel(pixels, size, cx + 6 + Math.floor(i / 4), shoulderTop + 10 + i, 0);
      }
      // Shoulder seam lines
      vLine(pixels, size, cx - shoulderW + 8, shoulderTop + 6, shoulderTop + 20, 0);
      vLine(pixels, size, cx + shoulderW - 8, shoulderTop + 6, shoulderTop + 20, 0);
      // Pocket on left side of jacket
      const pocketY = shoulderTop + 28;
      hLine(pixels, size, cx - 24, cx - 12, pocketY, 0);
      hLine(pixels, size, cx - 24, cx - 12, pocketY + 4, 0);
      vLine(pixels, size, cx - 24, pocketY, pocketY + 4, 0);
      vLine(pixels, size, cx - 12, pocketY, pocketY + 4, 0);
      // Asymmetry: right side gets a badge instead of a pocket
      fillRect(pixels, size, cx + 14, shoulderTop + 26, 6, 4, 0);
      fillRect(pixels, size, cx + 15, shoulderTop + 27, 4, 2, 1);
      // Buttons (center line)
      setPixel(pixels, size, cx - 3, shoulderTop + 20, 0);
      setPixel(pixels, size, cx - 3, shoulderTop + 28, 0);
      setPixel(pixels, size, cx - 3, shoulderTop + 36, 0);
    },
    drawNeck(pixels, size, rng) {
      const cx = 64;
      fillRect(pixels, size, cx - 7, 56, 14, 12, 1);
      // Neck shading — asymmetric: shadow on left
      vLine(pixels, size, cx - 5, 58, 64, 0);
    },
    drawHead(pixels, size, rng) {
      const cx = 64;
      // Main head oval centered
      fillEllipse(pixels, size, cx, 38, 22, 26, 1);
      // Jaw narrowing on both sides
      for (let y = 50; y < 56; y++) {
        const carve = Math.floor((y - 50) * 1.5);
        for (let x = 0; x < carve; x++) {
          setPixel(pixels, size, cx - 22 + x, y, 0);
          setPixel(pixels, size, cx + 22 - x, y, 0);
        }
      }
      // Chin definition
      hLine(pixels, size, cx - 12, cx + 12, 55, 0);
      // Left ear
      fillRect(pixels, size, cx - 24, 35, 3, 8, 1);
      setPixel(pixels, size, cx - 25, 36, 1);
      setPixel(pixels, size, cx - 25, 37, 1);
      setPixel(pixels, size, cx - 25, 38, 1);
      setPixel(pixels, size, cx - 23, 37, 0);
      setPixel(pixels, size, cx - 23, 38, 0);
      // Right ear
      fillRect(pixels, size, cx + 21, 35, 3, 8, 1);
      setPixel(pixels, size, cx + 24, 36, 1);
      setPixel(pixels, size, cx + 24, 37, 1);
      setPixel(pixels, size, cx + 24, 38, 1);
      setPixel(pixels, size, cx + 22, 37, 0);
      setPixel(pixels, size, cx + 22, 38, 0);
    },
    drawFace(pixels, size, rng) {
      const cx = 64;
      // Eyebrows — left
      hLine(pixels, size, cx - 18, cx - 12, 32, 0);
      hLine(pixels, size, cx - 18, cx - 12, 33, 0);
      // Eyebrows — right (slightly different arch)
      hLine(pixels, size, cx + 8, cx + 14, 32, 0);
      hLine(pixels, size, cx + 8, cx + 14, 33, 0);
      // Brow arch
      setPixel(pixels, size, cx - 19, 33, 0);
      setPixel(pixels, size, cx + 7, 33, 0);

      // Left eye
      fillRect(pixels, size, cx - 18, 36, 7, 4, 0);
      hLine(pixels, size, cx - 17, cx - 13, 35, 0);
      hLine(pixels, size, cx - 17, cx - 13, 40, 0);
      setPixel(pixels, size, cx - 15, 37, 1);
      setPixel(pixels, size, cx - 14, 37, 1);
      setPixel(pixels, size, cx - 15, 38, 1);
      setPixel(pixels, size, cx - 14, 38, 1);
      hLine(pixels, size, cx - 18, cx - 12, 35, 0);

      // Right eye
      fillRect(pixels, size, cx + 8, 36, 7, 4, 0);
      hLine(pixels, size, cx + 9, cx + 13, 35, 0);
      hLine(pixels, size, cx + 9, cx + 13, 40, 0);
      setPixel(pixels, size, cx + 10, 37, 1);
      setPixel(pixels, size, cx + 11, 37, 1);
      setPixel(pixels, size, cx + 10, 38, 1);
      setPixel(pixels, size, cx + 11, 38, 1);
      hLine(pixels, size, cx + 8, cx + 14, 35, 0);

      // Nose — centered
      vLine(pixels, size, cx - 1, 40, 46, 0);
      vLine(pixels, size, cx, 40, 46, 0);
      // Nostril hints
      setPixel(pixels, size, cx - 3, 46, 0);
      setPixel(pixels, size, cx - 2, 46, 0);
      setPixel(pixels, size, cx + 2, 46, 0);
      setPixel(pixels, size, cx + 3, 46, 0);
      setPixel(pixels, size, cx - 3, 45, 0);
      setPixel(pixels, size, cx + 3, 45, 0);

      // Mouth — centered
      hLine(pixels, size, cx - 10, cx + 8, 50, 0);
      hLine(pixels, size, cx - 9, cx + 7, 51, 0);
      hLine(pixels, size, cx - 7, cx + 5, 52, 0);
      // Upper lip
      setPixel(pixels, size, cx - 1, 49, 0);
      setPixel(pixels, size, cx, 49, 0);
    },
    drawHeadgear(pixels, size, rng) {
      const cx = 64;
      const style = Math.floor(rng() * 4);
      if (style === 0) {
        // Short crop
        fillRect(pixels, size, cx - 24, 10, 48, 5, 1);
        fillRect(pixels, size, cx - 26, 14, 52, 3, 1);
        for (let x = cx - 24; x < cx + 24; x += 2) {
          setPixel(pixels, size, x, 10, 0);
        }
        for (let x = cx - 23; x < cx + 23; x += 3) {
          setPixel(pixels, size, x, 12, 0);
        }
      } else if (style === 1) {
        // Longer hair — asymmetric: swept to the left
        fillRect(pixels, size, cx - 28, 8, 56, 8, 1);
        fillRect(pixels, size, cx - 30, 14, 8, 22, 1); // longer on left
        fillRect(pixels, size, cx + 22, 14, 5, 10, 1); // shorter on right
        // Hair texture
        for (let y = 10; y < 36; y += 2) {
          setPixel(pixels, size, cx - 29, y, 0);
        }
        for (let y = 9; y < 16; y++) {
          for (let x = cx - 26; x < cx + 24; x += 3) {
            setPixel(pixels, size, x, y, 0);
          }
        }
      } else if (style === 2) {
        // Mohawk — centered
        fillRect(pixels, size, cx - 7, 4, 14, 10, 1);
        fillRect(pixels, size, cx - 9, 6, 18, 8, 1);
        for (let y = 4; y < 14; y++) {
          setPixel(pixels, size, cx - 3, y, 0);
          setPixel(pixels, size, cx + 3, y, 0);
        }
      } else {
        // Buzzcut / bald — stubble texture
        for (let x = cx - 20; x < cx + 20; x += 2) {
          for (let y = 12; y < 18; y += 2) {
            setPixel(pixels, size, x, y, 0);
          }
        }
      }
    },
    drawDetails(pixels, size, rng) {
      const cx = 64;
      // Maybe add a scar — only on ONE side (asymmetric)
      if (rng() > 0.6) {
        const scarSide = rng() > 0.5 ? 1 : -1;
        const scarY = 36 + Math.floor(rng() * 10);
        vLine(pixels, size, cx + scarSide * 16, scarY, scarY + 6, 0);
        setPixel(pixels, size, cx + scarSide * 16 - 1, scarY + 1, 0);
        setPixel(pixels, size, cx + scarSide * 16 + 1, scarY + 5, 0);
      }
      // Stubble dots
      if (rng() > 0.5) {
        for (let y = 48; y < 55; y += 2) {
          for (let x = cx - 10; x < cx + 10; x += 3) {
            setPixel(pixels, size, x, y, 0);
          }
        }
      }
    }
  },

  // ════════════════════════════════════════════
  //  THARN
  // ════════════════════════════════════════════
  Tharn: {
    drawBody(pixels, size, rng) {
      const cx = 64;
      const shoulderTop = 65;
      const shoulderW = 60;
      // Enormous torso — full width
      fillRect(pixels, size, cx - shoulderW, shoulderTop + 10, shoulderW * 2, size - shoulderTop - 10, 1);
      // Shoulder slopes
      for (let i = 0; i < 12; i++) {
        const w = Math.floor(shoulderW * (i + 1) / 12);
        hLine(pixels, size, cx - w, cx + w, shoulderTop + i, 1);
      }
      // Left armor plate
      fillRect(pixels, size, cx - 58, shoulderTop + 8, 24, 2, 1);
      hLine(pixels, size, cx - 58, cx - 35, shoulderTop + 7, 0);
      hLine(pixels, size, cx - 58, cx - 35, shoulderTop + 10, 0);
      for (let x = cx - 56; x < cx - 36; x += 4) {
        setPixel(pixels, size, x, shoulderTop + 9, 0);
      }
      // Right armor plate — asymmetric: bigger with spike
      fillRect(pixels, size, cx + 32, shoulderTop + 7, 28, 3, 1);
      hLine(pixels, size, cx + 32, cx + 59, shoulderTop + 6, 0);
      hLine(pixels, size, cx + 32, cx + 59, shoulderTop + 10, 0);
      for (let x = cx + 34; x < cx + 58; x += 4) {
        setPixel(pixels, size, x, shoulderTop + 8, 0);
      }
      // Spike on right shoulder
      fillTriangle(pixels, size, cx + 48, shoulderTop + 6, cx + 52, shoulderTop + 6, cx + 50, shoulderTop - 2, 1);
      // Chest plate
      hLine(pixels, size, cx - 30, cx + 30, shoulderTop + 16, 0);
      hLine(pixels, size, cx - 30, cx + 30, shoulderTop + 17, 0);
      // Chest cross-strap — left-to-right diagonal
      for (let i = 0; i < 20; i++) {
        setPixel(pixels, size, cx - 20 + Math.floor(i * 1.8), shoulderTop + 18 + i, 0);
        setPixel(pixels, size, cx - 19 + Math.floor(i * 1.8), shoulderTop + 18 + i, 0);
      }
      // Belt
      hLine(pixels, size, cx - shoulderW, cx + shoulderW, shoulderTop + 40, 0);
      hLine(pixels, size, cx - shoulderW, cx + shoulderW, shoulderTop + 41, 0);
      hLine(pixels, size, cx - shoulderW, cx + shoulderW, shoulderTop + 43, 0);
      // Belt buckle — centered
      fillRect(pixels, size, cx - 4, shoulderTop + 38, 8, 7, 0);
      fillRect(pixels, size, cx - 2, shoulderTop + 39, 4, 5, 1);
    },
    drawNeck(pixels, size, rng) {
      const cx = 64;
      fillRect(pixels, size, cx - 14, 56, 28, 12, 1);
      // Neck tendons — asymmetric
      vLine(pixels, size, cx - 10, 58, 66, 0);
      vLine(pixels, size, cx - 4, 57, 66, 0);
      vLine(pixels, size, cx + 6, 58, 66, 0);
    },
    drawHead(pixels, size, rng) {
      const cx = 64;
      // Massive wide skull
      fillEllipse(pixels, size, cx, 38, 32, 25, 1);
      // Heavy brow ridge
      fillRect(pixels, size, cx - 32, 30, 64, 5, 1);
      hLine(pixels, size, cx - 30, cx + 30, 35, 0);
      // Squared jaw
      fillRect(pixels, size, cx - 28, 46, 56, 10, 1);
      vLine(pixels, size, cx - 28, 46, 56, 0);
      vLine(pixels, size, cx + 28, 46, 56, 0);
      hLine(pixels, size, cx - 28, cx + 28, 56, 0);
    },
    drawFace(pixels, size, rng) {
      const cx = 64;
      // Deep-set small eyes
      // Left eye
      fillRect(pixels, size, cx - 18, 36, 5, 3, 0);
      setPixel(pixels, size, cx - 16, 37, 1);
      setPixel(pixels, size, cx - 15, 37, 1);
      // Right eye
      fillRect(pixels, size, cx + 10, 36, 5, 3, 0);
      setPixel(pixels, size, cx + 12, 37, 1);
      setPixel(pixels, size, cx + 13, 37, 1);

      // Broad flat nose
      fillRect(pixels, size, cx - 6, 40, 12, 6, 0);
      vLine(pixels, size, cx - 1, 38, 40, 0);
      vLine(pixels, size, cx, 38, 40, 0);
      fillRect(pixels, size, cx - 6, 44, 3, 2, 0);
      fillRect(pixels, size, cx + 3, 44, 3, 2, 0);

      // Mouth
      hLine(pixels, size, cx - 16, cx + 12, 49, 0);
      hLine(pixels, size, cx - 14, cx + 10, 50, 0);

      // Tusks — asymmetric sizes
      // Left tusk (bigger)
      fillRect(pixels, size, cx - 22, 52, 3, 7, 1);
      fillRect(pixels, size, cx - 21, 58, 1, 2, 1);
      setPixel(pixels, size, cx - 22, 53, 0);
      setPixel(pixels, size, cx - 22, 55, 0);
      // Right tusk (smaller)
      fillRect(pixels, size, cx + 18, 52, 3, 5, 1);
      setPixel(pixels, size, cx + 20, 53, 0);
      // Inner tusk left
      fillRect(pixels, size, cx - 10, 53, 2, 4, 1);
      // Inner tusk right
      fillRect(pixels, size, cx + 8, 53, 2, 3, 1);
    },
    drawHeadgear(pixels, size, rng) {
      const cx = 64;
      // Cranial ridges — asymmetric: different heights on each side
      const ridgeCountL = 1 + Math.floor(rng() * 2);
      const ridgeCountR = 1 + Math.floor(rng() * 2);
      // Left ridges
      for (let r = 0; r < ridgeCountL; r++) {
        const rx = cx - 12 - r * 10;
        const ridgeH = 14 + Math.floor(rng() * 6);
        fillRect(pixels, size, rx, 24 - ridgeH, 4, ridgeH, 1);
        fillRect(pixels, size, rx + 1, 22 - ridgeH, 2, 3, 1);
        for (let y = 24 - ridgeH; y < 24; y += 3) {
          hLine(pixels, size, rx, rx + 3, y, 0);
        }
      }
      // Right ridges — different count and heights
      for (let r = 0; r < ridgeCountR; r++) {
        const rx = cx + 8 + r * 10;
        const ridgeH = 12 + Math.floor(rng() * 8);
        fillRect(pixels, size, rx, 24 - ridgeH, 4, ridgeH, 1);
        fillRect(pixels, size, rx + 1, 22 - ridgeH, 2, 3, 1);
        for (let y = 24 - ridgeH; y < 24; y += 3) {
          hLine(pixels, size, rx, rx + 3, y, 0);
        }
      }
      // Brow ridge texture
      for (let x = cx - 30; x < cx + 30; x += 4) {
        setPixel(pixels, size, x, 31, 0);
        setPixel(pixels, size, x, 32, 0);
      }
    },
    drawDetails(pixels, size, rng) {
      const cx = 64;
      // War paint / scars — only on one cheek
      if (rng() > 0.4) {
        const scarSide = rng() > 0.5 ? -1 : 1;
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 5; j++) {
            setPixel(pixels, size, cx + scarSide * (20 + i * 3) + j, 42 + j, 0);
          }
        }
      }
      // Skin texture
      for (let y = 36; y < 55; y += 4) {
        for (let x = cx - 25; x < cx + 25; x += 6) {
          if (rng() > 0.5) setPixel(pixels, size, x, y, 0);
        }
      }
    }
  },

  // ════════════════════════════════════════════
  //  CEPHALID
  // ════════════════════════════════════════════
  Cephalid: {
    drawBody(pixels, size, rng) {
      const cx = 64;
      const shoulderTop = 82;
      // Robe body — flowing, centered
      for (let y = shoulderTop; y < size; y++) {
        const progress = (y - shoulderTop) / (size - shoulderTop);
        const w = Math.floor(30 + progress * 15);
        hLine(pixels, size, cx - w, cx + w, y, 1);
      }
      // Robe fold lines — asymmetric placement
      for (let y = shoulderTop + 4; y < size; y += 2) {
        setPixel(pixels, size, cx - 14, y, 0);
      }
      for (let y = shoulderTop + 6; y < size; y += 3) {
        setPixel(pixels, size, cx + 8, y, 0);
      }
      for (let y = shoulderTop + 8; y < size; y += 4) {
        setPixel(pixels, size, cx + 18, y, 0);
      }
      // Robe collar
      fillRect(pixels, size, cx - 6, shoulderTop, 12, 3, 1);
      fillRect(pixels, size, cx - 5, shoulderTop + 1, 10, 1, 0);
      // Robe trim
      hLine(pixels, size, cx - 30, cx + 30, shoulderTop + 3, 0);
    },
    drawNeck(pixels, size, rng) {
      const cx = 64;
      fillRect(pixels, size, cx - 6, 72, 12, 12, 1);
    },
    drawHead(pixels, size, rng) {
      const cx = 64;
      // Huge bulbous dome — centered
      fillEllipse(pixels, size, cx, 28, 40, 30, 1);
      // Extended dome top
      fillEllipse(pixels, size, cx, 18, 32, 18, 1);
      // Dome highlight contour
      ellipseOutline(pixels, size, cx, 18, 30, 16, 0);
      // Restore interior
      fillEllipse(pixels, size, cx, 20, 28, 14, 1);
    },
    drawFace(pixels, size, rng) {
      const cx = 64;
      // Large almond-shaped eyes
      // Left eye
      fillEllipse(pixels, size, cx - 16, 34, 8, 5, 0);
      fillEllipse(pixels, size, cx - 15, 34, 4, 2, 1);
      setPixel(pixels, size, cx - 14, 34, 0);
      setPixel(pixels, size, cx - 15, 34, 0);
      // Right eye — slightly different shape (asymmetry)
      fillEllipse(pixels, size, cx + 14, 34, 9, 5, 0);
      fillEllipse(pixels, size, cx + 15, 34, 5, 2, 1);
      setPixel(pixels, size, cx + 15, 34, 0);
      setPixel(pixels, size, cx + 14, 34, 0);

      // Tentacles — each individually placed (no mirror)
      const tentCount = 4 + Math.floor(rng() * 3);
      const tentStartY = 48;
      const totalSpan = 48;
      const tentSpacing = Math.floor(totalSpan / tentCount);
      for (let t = 0; t < tentCount; t++) {
        const tx = cx - 24 + t * tentSpacing + Math.floor(rng() * 4 - 2);
        const tentLen = 16 + Math.floor(rng() * 14);
        const wavePhase = rng() * 6.28;
        const waveAmp = 1.5 + rng() * 1.5;
        for (let ty = 0; ty < tentLen; ty++) {
          const wave = Math.round(Math.sin(ty * 0.4 + wavePhase) * waveAmp);
          setPixel(pixels, size, tx + wave, tentStartY + ty, 1);
          setPixel(pixels, size, tx + wave + 1, tentStartY + ty, 1);
          if (ty < tentLen / 3) {
            setPixel(pixels, size, tx + wave + 2, tentStartY + ty, 1);
          }
          if (ty % 4 === 2 && ty > 2) {
            setPixel(pixels, size, tx + wave + 1, tentStartY + ty, 0);
          }
        }
        setPixel(pixels, size, tx, tentStartY + tentLen, 1);
      }
    },
    drawHeadgear(pixels, size, rng) {
      const cx = 64;
      // Vein lines — randomly placed, naturally asymmetric
      const veinCount = 4 + Math.floor(rng() * 4);
      for (let v = 0; v < veinCount; v++) {
        let vx = cx - 25 + Math.floor(rng() * 50);
        let vy = 4 + Math.floor(rng() * 16);
        const veinLen = 8 + Math.floor(rng() * 12);
        for (let i = 0; i < veinLen; i++) {
          setPixel(pixels, size, vx, vy + i, 0);
          vx += Math.round(rng() * 2 - 1);
          if (i === Math.floor(veinLen / 2) && rng() > 0.5) {
            const branchDir = rng() > 0.5 ? 1 : -1;
            for (let b = 0; b < 4; b++) {
              setPixel(pixels, size, vx + branchDir * b, vy + i + b, 0);
            }
          }
        }
      }
    },
    drawDetails(pixels, size, rng) {
      const cx = 64;
      // Dome texture spots
      for (let i = 0; i < 12; i++) {
        const dx = cx - 30 + Math.floor(rng() * 60);
        const dy = 6 + Math.floor(rng() * 25);
        setPixel(pixels, size, dx, dy, 0);
      }
      // Eye ridge — both sides
      hLine(pixels, size, cx - 26, cx - 8, 28, 0);
      hLine(pixels, size, cx + 6, cx + 24, 28, 0);
    }
  },

  // ════════════════════════════════════════════
  //  GRAVBORN
  // ════════════════════════════════════════════
  Gravborn: {
    drawBody(pixels, size, rng) {
      const cx = 64;
      const shoulderTop = 58;
      const shoulderW = 60;
      // Massive torso
      fillRect(pixels, size, cx - shoulderW, shoulderTop + 12, shoulderW * 2, size - shoulderTop - 12, 1);
      // Shoulder slopes
      for (let i = 0; i < 14; i++) {
        const w = Math.floor(shoulderW * (i + 1) / 14);
        hLine(pixels, size, cx - w, cx + w, shoulderTop + i, 1);
      }
      // Suit collar
      fillRect(pixels, size, cx - 9, shoulderTop, 18, 6, 1);
      hLine(pixels, size, cx - 9, cx + 9, shoulderTop - 1, 1);

      // Utility belt
      const beltY = shoulderTop + 42;
      hLine(pixels, size, cx - shoulderW, cx + shoulderW, beltY, 0);
      hLine(pixels, size, cx - shoulderW, cx + shoulderW, beltY + 1, 0);
      hLine(pixels, size, cx - shoulderW, cx + shoulderW, beltY + 3, 0);
      hLine(pixels, size, cx - shoulderW, cx + shoulderW, beltY + 4, 0);
      // Belt pouches — asymmetric: more on right side
      fillRect(pixels, size, cx - 50, beltY + 1, 8, 3, 1);
      fillRect(pixels, size, cx - 38, beltY + 1, 6, 3, 1);
      fillRect(pixels, size, cx + 30, beltY + 1, 10, 3, 1);
      fillRect(pixels, size, cx + 44, beltY + 1, 6, 3, 1);
      fillRect(pixels, size, cx + 52, beltY + 1, 5, 3, 1);

      // Suit panel lines
      vLine(pixels, size, cx - 30, shoulderTop + 14, beltY - 2, 0);
      vLine(pixels, size, cx + 30, shoulderTop + 14, beltY - 2, 0);
      // Chest pocket (left side only — asymmetric)
      fillRect(pixels, size, cx - 22, shoulderTop + 16, 10, 8, 0);
      fillRect(pixels, size, cx - 20, shoulderTop + 17, 6, 6, 1);
      fillRect(pixels, size, cx - 20, shoulderTop + 18, 5, 2, 0);

      // Arm seams
      vLine(pixels, size, cx - shoulderW + 6, shoulderTop + 12, size - 1, 0);
      vLine(pixels, size, cx + shoulderW - 6, shoulderTop + 12, size - 1, 0);
    },
    drawNeck(pixels, size, rng) {
      const cx = 64;
      fillRect(pixels, size, cx - 10, 52, 20, 8, 1);
    },
    drawHead(pixels, size, rng) {
      const cx = 64;
      // Mining helmet dome
      fillEllipse(pixels, size, cx, 38, 22, 18, 1);
      fillRect(pixels, size, cx - 22, 38, 44, 14, 1);
      // Helmet rim
      hLine(pixels, size, cx - 24, cx + 24, 52, 1);
      hLine(pixels, size, cx - 24, cx + 24, 53, 1);
      hLine(pixels, size, cx - 24, cx + 24, 54, 0);
      // Helmet top ridge
      hLine(pixels, size, cx - 14, cx + 14, 20, 1);
      hLine(pixels, size, cx - 16, cx + 16, 21, 1);
      fillRect(pixels, size, cx - 18, 22, 36, 2, 1);
    },
    drawFace(pixels, size, rng) {
      const cx = 64;
      // Visor
      const visorY = 38;
      fillRect(pixels, size, cx - 22, visorY, 44, 5, 0);
      fillRect(pixels, size, cx - 20, visorY + 1, 40, 3, 1);
      // Visor reflections — asymmetric glint
      hLine(pixels, size, cx - 16, cx - 8, visorY + 1, 0);
      setPixel(pixels, size, cx + 6, visorY + 2, 0);
      setPixel(pixels, size, cx + 10, visorY + 2, 0);

      // Respirator mask
      fillRect(pixels, size, cx - 18, 44, 36, 10, 1);
      for (let y = 45; y < 53; y += 2) {
        hLine(pixels, size, cx - 16, cx + 16, y, 0);
      }
      // Left side vent
      fillRect(pixels, size, cx - 20, 46, 3, 6, 0);
      setPixel(pixels, size, cx - 19, 47, 1);
      setPixel(pixels, size, cx - 19, 49, 1);
      setPixel(pixels, size, cx - 19, 51, 1);
      // Right side vent
      fillRect(pixels, size, cx + 17, 46, 3, 6, 0);
      setPixel(pixels, size, cx + 18, 47, 1);
      setPixel(pixels, size, cx + 18, 49, 1);
      setPixel(pixels, size, cx + 18, 51, 1);
      // Respirator bottom
      hLine(pixels, size, cx - 18, cx + 18, 54, 0);
      // Chin straps
      vLine(pixels, size, cx - 18, 44, 54, 0);
      vLine(pixels, size, cx + 18, 44, 54, 0);
    },
    drawHeadgear(pixels, size, rng) {
      const cx = 64;
      // Mining headlamp — offset from center (asymmetric)
      const lampOff = Math.floor(rng() * 6) - 3;
      const lampX = cx + lampOff;
      const lampY = 22;
      fillRect(pixels, size, lampX - 3, lampY - 4, 7, 5, 1);
      fillRect(pixels, size, lampX - 2, lampY - 3, 5, 3, 0);
      fillRect(pixels, size, lampX - 1, lampY - 2, 3, 1, 1);
      vLine(pixels, size, lampX, lampY + 1, lampY + 3, 1);
      // Helmet surface lines
      for (let x = cx - 16; x < cx + 16; x += 6) {
        vLine(pixels, size, x, 24, 36, 0);
      }
    },
    drawDetails(pixels, size, rng) {
      const cx = 64;
      // Dust/scratches on helmet
      if (rng() > 0.3) {
        for (let i = 0; i < 6; i++) {
          const sx = cx - 18 + Math.floor(rng() * 36);
          const sy = 24 + Math.floor(rng() * 12);
          setPixel(pixels, size, sx, sy, 0);
          setPixel(pixels, size, sx + 1, sy + 1, 0);
        }
      }
      // Suit patch — only on one shoulder (asymmetric)
      if (rng() > 0.4) {
        const patchSide = rng() > 0.5 ? -1 : 1;
        const patchX = cx + patchSide * 40;
        const patchY = 72;
        fillRect(pixels, size, patchX, patchY, 8, 6, 0);
        fillRect(pixels, size, patchX + 1, patchY + 1, 6, 4, 1);
        setPixel(pixels, size, patchX + 3, patchY + 2, 0);
        setPixel(pixels, size, patchX + 4, patchY + 3, 0);
        setPixel(pixels, size, patchX + 5, patchY + 2, 0);
      }
    }
  },

  // ════════════════════════════════════════════
  //  INSECTOID
  // ════════════════════════════════════════════
  Insectoid: {
    drawBody(pixels, size, rng) {
      const cx = 64;
      const thoraxTop = 60;
      const segCount = 3 + Math.floor(rng() * 2);
      const segH = Math.floor((size - thoraxTop) / segCount);
      for (let s = 0; s < segCount; s++) {
        const segY = thoraxTop + s * segH;
        const maxW = 28 + s * 5;
        for (let y = 0; y < segH; y++) {
          const t = y / segH;
          const widthFactor = Math.sin(t * Math.PI);
          const w = Math.floor(maxW * (0.6 + 0.4 * widthFactor));
          hLine(pixels, size, cx - w, cx + w, segY + y, 1);
        }
        if (s < segCount - 1) {
          const jointY = segY + segH - 1;
          hLine(pixels, size, cx - maxW + 6, cx + maxW - 6, jointY, 0);
        }
        const midY = segY + Math.floor(segH / 2);
        for (let x = cx - maxW + 4; x < cx + maxW - 4; x += 5) {
          setPixel(pixels, size, x, midY, 0);
          setPixel(pixels, size, x + 1, midY - 1, 0);
          setPixel(pixels, size, x + 1, midY + 1, 0);
        }
      }
      // Limb attachment points — both sides, asymmetric
      const armY = thoraxTop + 4;
      fillRect(pixels, size, cx - 32, armY, 4, 3, 1);
      fillRect(pixels, size, cx - 34, armY + 1, 2, 1, 1);
      fillRect(pixels, size, cx + 28, armY, 4, 4, 1); // right side slightly bigger
      fillRect(pixels, size, cx + 32, armY + 1, 2, 2, 1);
    },
    drawNeck(pixels, size, rng) {
      const cx = 64;
      fillRect(pixels, size, cx - 6, 48, 12, 14, 1);
      hLine(pixels, size, cx - 5, cx + 5, 52, 0);
      hLine(pixels, size, cx - 5, cx + 5, 56, 0);
    },
    drawHead(pixels, size, rng) {
      const cx = 64;
      // Narrow angular head
      fillEllipse(pixels, size, cx, 30, 20, 14, 1);
      // Angular jaw taper — both sides
      for (let y = 35; y < 48; y++) {
        const taper = Math.floor((y - 35) * 1.2);
        for (let x = 0; x < taper; x++) {
          setPixel(pixels, size, cx - 20 + x, y, 0);
          setPixel(pixels, size, cx + 20 - x, y, 0);
        }
      }
      // Pointed chin
      fillTriangle(pixels, size, cx - 10, 42, cx + 10, 42, cx, 50, 1);
      // Head carapace edge
      hLine(pixels, size, cx - 22, cx + 22, 16, 1);
      hLine(pixels, size, cx - 24, cx + 24, 17, 1);
    },
    drawFace(pixels, size, rng) {
      const cx = 64;
      // Left compound eye — larger
      fillEllipse(pixels, size, cx - 12, 28, 9, 7, 0);
      for (let ey = -5; ey <= 5; ey += 3) {
        for (let ex = -7; ex <= 1; ex += 3) {
          const dx = cx - 12 + ex + ((ey % 2 === 0) ? 1 : 0);
          const dy = 28 + ey;
          if ((ex * ex) / 64 + (ey * ey) / 36 < 0.8) {
            setPixel(pixels, size, dx, dy, 1);
          }
        }
      }
      // Right compound eye — slightly smaller (asymmetric)
      fillEllipse(pixels, size, cx + 10, 28, 7, 6, 0);
      for (let ey = -4; ey <= 4; ey += 3) {
        for (let ex = -5; ex <= 5; ex += 3) {
          const dx = cx + 10 + ex + ((ey % 2 === 0) ? 1 : 0);
          const dy = 28 + ey;
          if ((ex * ex) / 36 + (ey * ey) / 25 < 0.7) {
            setPixel(pixels, size, dx, dy, 1);
          }
        }
      }

      // Mandibles — asymmetric
      // Left mandible — curves outward more
      for (let i = 0; i < 8; i++) {
        setPixel(pixels, size, cx - 8 - Math.floor(i * 1.0), 44 + i, 1);
        setPixel(pixels, size, cx - 7 - Math.floor(i * 1.0), 44 + i, 1);
        setPixel(pixels, size, cx - 6 - Math.floor(i * 1.0), 44 + i, 1);
      }
      // Right mandible — straighter
      for (let i = 0; i < 8; i++) {
        setPixel(pixels, size, cx + 4 + Math.floor(i * 0.4), 44 + i, 1);
        setPixel(pixels, size, cx + 5 + Math.floor(i * 0.4), 44 + i, 1);
        setPixel(pixels, size, cx + 6 + Math.floor(i * 0.4), 44 + i, 1);
      }
      // Mandible serration on left only
      for (let i = 0; i < 6; i += 2) {
        setPixel(pixels, size, cx - 9 - Math.floor(i * 1.0), 45 + i, 0);
      }
    },
    drawHeadgear(pixels, size, rng) {
      const cx = 64;
      // Left antenna — longer, more curved
      for (let i = 0; i < 22; i++) {
        const ax = cx - 10 - Math.floor(i * 0.6) + Math.round(Math.sin(i * 0.15) * 2);
        setPixel(pixels, size, ax, 16 - i, 1);
        setPixel(pixels, size, ax + 1, 16 - i, 1);
      }
      fillEllipse(pixels, size, cx - 22, -5, 2, 2, 1);

      // Right antenna — shorter, different angle (asymmetric)
      for (let i = 0; i < 18; i++) {
        const ax = cx + 8 + Math.floor(i * 0.3) + Math.round(Math.sin(i * 0.2) * 1.5);
        setPixel(pixels, size, ax, 16 - i, 1);
        setPixel(pixels, size, ax + 1, 16 - i, 1);
      }
      fillEllipse(pixels, size, cx + 14, -1, 2, 2, 1);

      // Head carapace ridge
      hLine(pixels, size, cx - 20, cx + 20, 18, 0);
    },
    drawDetails(pixels, size, rng) {
      const cx = 64;
      // Chitin texture
      for (let y = 20; y < 35; y += 4) {
        for (let x = cx - 18; x < cx + 18; x += 5) {
          if (rng() > 0.4) {
            setPixel(pixels, size, x, y, 0);
          }
        }
      }
      // Wing stubs — only on one side (asymmetric)
      if (rng() > 0.3) {
        const wingSide = rng() > 0.5 ? -1 : 1;
        const wingY = 62;
        for (let i = 0; i < 6; i++) {
          setPixel(pixels, size, cx + wingSide * (28 + i), wingY + i, 1);
          setPixel(pixels, size, cx + wingSide * (29 + i), wingY + i, 1);
          setPixel(pixels, size, cx + wingSide * (30 + i), wingY + i + 1, 1);
        }
      }
      // Speckle pattern
      for (let i = 0; i < 8; i++) {
        const sx = cx - 16 + Math.floor(rng() * 32);
        const sy = 22 + Math.floor(rng() * 10);
        setPixel(pixels, size, sx, sy, 0);
      }
    }
  },

  // ════════════════════════════════════════════
  //  CONSTRUCT
  // ════════════════════════════════════════════
  Construct: {
    drawBody(pixels, size, rng) {
      const cx = 64;
      const shoulderTop = 58;
      const shoulderW = 54;
      // Shoulder plates
      fillRect(pixels, size, cx - shoulderW, shoulderTop + 4, shoulderW * 2, 8, 1);
      // Shoulder step
      fillRect(pixels, size, cx - shoulderW + 8, shoulderTop, (shoulderW - 8) * 2, 4, 1);
      // Body
      fillRect(pixels, size, cx - shoulderW + 8, shoulderTop + 12, (shoulderW - 8) * 2, size - shoulderTop - 12, 1);

      // Panel lines grid
      for (let y = shoulderTop + 16; y < size; y += 8) {
        hLine(pixels, size, cx - shoulderW + 10, cx + shoulderW - 10, y, 0);
      }
      for (let x = cx - 30; x < cx + 30; x += 10) {
        vLine(pixels, size, x, shoulderTop + 14, size - 1, 0);
      }
      // Chest plate — centered
      fillRect(pixels, size, cx - 10, shoulderTop + 14, 20, 12, 0);
      fillRect(pixels, size, cx - 8, shoulderTop + 16, 16, 8, 1);
      // LED indicator
      fillRect(pixels, size, cx - 2, shoulderTop + 18, 4, 4, 0);
      fillRect(pixels, size, cx - 1, shoulderTop + 19, 2, 2, 1);

      // Shoulder rivets
      for (let x = cx - shoulderW + 4; x < cx + shoulderW - 4; x += 8) {
        setPixel(pixels, size, x, shoulderTop + 5, 0);
        setPixel(pixels, size, x, shoulderTop + 10, 0);
      }
      // Left shoulder joint
      fillRect(pixels, size, cx - shoulderW, shoulderTop + 4, 4, 8, 0);
      fillRect(pixels, size, cx - shoulderW + 1, shoulderTop + 5, 2, 6, 1);
      // Right shoulder joint
      fillRect(pixels, size, cx + shoulderW - 4, shoulderTop + 4, 4, 8, 0);
      fillRect(pixels, size, cx + shoulderW - 3, shoulderTop + 5, 2, 6, 1);
    },
    drawNeck(pixels, size, rng) {
      const cx = 64;
      // Mechanical piston rods — both sides
      fillRect(pixels, size, cx - 10, 46, 6, 14, 1);
      fillRect(pixels, size, cx + 4, 46, 6, 14, 1);
      // Gap between
      fillRect(pixels, size, cx - 4, 46, 8, 14, 0);
      // Piston lines
      hLine(pixels, size, cx - 10, cx - 5, 50, 0);
      hLine(pixels, size, cx + 4, cx + 9, 50, 0);
      hLine(pixels, size, cx - 10, cx - 5, 54, 0);
      hLine(pixels, size, cx + 4, cx + 9, 54, 0);
      // Connector plate
      fillRect(pixels, size, cx - 12, 44, 24, 3, 1);
      hLine(pixels, size, cx - 12, cx + 12, 43, 0);
    },
    drawHead(pixels, size, rng) {
      const cx = 64;
      // Rectangular head
      fillRect(pixels, size, cx - 16, 16, 32, 28, 1);
      // Edge definition
      hLine(pixels, size, cx - 16, cx + 16, 16, 0);
      hLine(pixels, size, cx - 16, cx + 16, 43, 0);
      vLine(pixels, size, cx - 16, 16, 43, 0);
      vLine(pixels, size, cx + 16, 16, 43, 0);
      // Internal frame
      hLine(pixels, size, cx - 14, cx + 14, 18, 0);
      hLine(pixels, size, cx - 14, cx + 14, 41, 0);
      vLine(pixels, size, cx - 14, 18, 41, 0);
      vLine(pixels, size, cx + 14, 18, 41, 0);
    },
    drawFace(pixels, size, rng) {
      const cx = 64;
      // Sensor slit
      fillRect(pixels, size, cx - 14, 26, 28, 4, 0);
      fillRect(pixels, size, cx - 12, 27, 24, 2, 1);
      // Sensor dots
      for (let x = cx - 10; x < cx + 10; x += 4) {
        setPixel(pixels, size, x, 27, 0);
        setPixel(pixels, size, x, 28, 0);
      }

      // Speaker grille
      for (let y = 34; y < 41; y += 2) {
        hLine(pixels, size, cx - 10, cx + 10, y, 0);
      }
      // Grille border
      vLine(pixels, size, cx - 12, 33, 41, 0);
      vLine(pixels, size, cx + 12, 33, 41, 0);
      hLine(pixels, size, cx - 12, cx + 12, 33, 0);
      hLine(pixels, size, cx - 12, cx + 12, 41, 0);
    },
    drawHeadgear(pixels, size, rng) {
      const cx = 64;
      // Antenna — asymmetric: placed off-center
      const antennaOff = Math.floor(rng() * 8) - 4;
      const antennaX = cx + antennaOff;
      vLine(pixels, size, antennaX, 2, 16, 1);
      vLine(pixels, size, antennaX + 1, 2, 16, 1);
      fillEllipse(pixels, size, antennaX, 2, 3, 3, 1);
      setPixel(pixels, size, antennaX, 2, 0);
      fillRect(pixels, size, antennaX - 2, 14, 6, 3, 1);
      // Second smaller antenna on opposite side (asymmetric)
      if (rng() > 0.4) {
        const ant2X = cx - antennaOff - 6;
        vLine(pixels, size, ant2X, 8, 16, 1);
        fillEllipse(pixels, size, ant2X, 8, 2, 2, 1);
        setPixel(pixels, size, ant2X, 8, 0);
      }
    },
    drawDetails(pixels, size, rng) {
      const cx = 64;
      // Serial number markings — on one side only
      const markY = 20;
      const markSide = rng() > 0.5 ? -1 : 1;
      for (let i = 0; i < 4; i++) {
        if (rng() > 0.4) {
          fillRect(pixels, size, cx + markSide * (3 + i * 3), markY, 2, 3, 0);
        }
      }
      // Status LEDs — left side of body
      const ledY = 68;
      for (let i = 0; i < 3; i++) {
        setPixel(pixels, size, cx - 3, ledY + i * 4, 0);
        setPixel(pixels, size, cx - 2, ledY + i * 4, 0);
      }
      // Wear marks / scratches — random
      if (rng() > 0.3) {
        for (let i = 0; i < 5; i++) {
          const sx = cx - 14 + Math.floor(rng() * 28);
          const sy = 20 + Math.floor(rng() * 20);
          setPixel(pixels, size, sx, sy, 0);
          setPixel(pixels, size, sx + 1, sy, 0);
        }
      }
      // Panel screws — both sides
      for (let y = 70; y < size - 4; y += 12) {
        for (let x = cx - 40; x < cx + 40; x += 14) {
          setPixel(pixels, size, x, y, 0);
          setPixel(pixels, size, x + 1, y, 0);
          setPixel(pixels, size, x, y + 1, 0);
        }
      }
    }
  }
};

// ── Portrait Generation ──
function generatePortrait(race, rng) {
  const size = 128;
  const pixels = new Uint8Array(size * size);

  const drawer = RACE_DRAWERS[race];

  // Draw layers bottom to top
  drawer.drawBody(pixels, size, rng);
  drawer.drawNeck(pixels, size, rng);
  drawer.drawHead(pixels, size, rng);
  drawer.drawFace(pixels, size, rng);
  drawer.drawHeadgear(pixels, size, rng);
  drawer.drawDetails(pixels, size, rng);

  return pixels;
}

function generateCharacter(race, seed) {
  const rng = createRNG(seed);
  return {
    name: generateName(race, rng),
    race: race,
    portrait: generatePortrait(race, rng),
    seed: seed,
  };
}

// ── Card Rendering ──
function renderCard(character) {
  const card = document.createElement('div');
  card.className = 'card';
  card.dataset.seed = character.seed;

  // Portrait canvas
  const canvas = document.createElement('canvas');
  canvas.width = 128;
  canvas.height = 128;
  const ctx = canvas.getContext('2d');
  const imageData = ctx.createImageData(128, 128);

  for (let i = 0; i < character.portrait.length; i++) {
    const v = character.portrait[i] ? 0 : 255;
    const idx = i * 4;
    imageData.data[idx] = v;     // R
    imageData.data[idx + 1] = v; // G
    imageData.data[idx + 2] = v; // B
    imageData.data[idx + 3] = 255; // A
  }
  ctx.putImageData(imageData, 0, 0);

  // Name label
  const name = document.createElement('div');
  name.className = 'name';
  name.textContent = character.name;

  // Race tag
  const tag = document.createElement('div');
  tag.className = 'race-tag';
  tag.textContent = character.race;

  card.appendChild(canvas);
  card.appendChild(name);
  card.appendChild(tag);

  return card;
}

const RACES = ['Human', 'Tharn', 'Cephalid', 'Gravborn', 'Insectoid', 'Construct'];

function generateRoster() {
  return RACES.map(race => generateCharacter(race, Math.floor(Math.random() * 100000)));
}

let roster = generateRoster();

function renderSelectionScreen() {
  const grid = document.getElementById('card-grid');
  grid.innerHTML = '';
  roster.forEach((char, i) => {
    const card = renderCard(char);
    card.addEventListener('click', () => handleCardClick(i));
    grid.appendChild(card);
  });
}

// ── Game State ──
let selectedIndices = [];

function updateSelectionUI() {
  const counter = document.getElementById('selection-counter');
  const btn = document.getElementById('btn-start');
  counter.textContent = `${selectedIndices.length} / 2 selected`;
  btn.disabled = selectedIndices.length !== 2;

  document.querySelectorAll('.card').forEach((card, i) => {
    card.classList.toggle('selected', selectedIndices.includes(i));
  });
}

function handleCardClick(index) {
  const pos = selectedIndices.indexOf(index);
  if (pos !== -1) {
    selectedIndices.splice(pos, 1);
  } else if (selectedIndices.length < 2) {
    selectedIndices.push(index);
  }
  updateSelectionUI();
}

// ── Screen Switching ──
function showScreen(screenId) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(screenId).classList.add('active');
}

// ── Mission Flow ──
document.getElementById('btn-start').addEventListener('click', () => {
  startMission();
});

function startMission() {
  const selected = selectedIndices.map(i => roster[i]);
  showScreen('screen-waiting');
  renderWaitingScreen(selected);
  setTimeout(() => showResult(selected), 5000);
}

// ── Waiting Screen ──
function renderWaitingScreen(selected) {
  const container = document.getElementById('waiting-cards');
  container.innerHTML = '';
  selected.forEach(char => container.appendChild(renderCard(char)));
}

// ── Narrative Pools ──
const NARRATIVES = {
  success: [
    "{name1} drew their fire while {name2} secured the objective. Clean extraction.",
    "{name2} almost blew the cover, but {name1} improvised. Mission complete.",
    "Textbook operation. {name1} and {name2} made it look easy.",
    "{name1} cracked the encryption. {name2} held the corridor. Data secured.",
    "Against the odds, {name2} found an alternate route. {name1} covered the exit.",
    "{name1} and {name2} moved like they'd trained together for years. Flawless.",
    "The target never saw {name2} coming. {name1} handled the getaway.",
    "{name1} took point. {name2} watched their six. Not a scratch on either.",
    "Messy start, clean finish. {name2} adapted fast. {name1} kept their nerve.",
    "{name1} disabled the alarms. {name2} grabbed the payload. In and out.",
  ],
  failure: [
    "{name1} took a hit in the first corridor. {name2} dragged them out. No payload.",
    "Bad intel. {name1} and {name2} walked into a trap. Barely made it back.",
    "{name2} froze under fire. {name1} called the abort. Live to fight another day.",
    "The lock was military-grade. {name1} couldn't crack it. {name2} burned through their ammo covering.",
    "{name1} and {name2} got separated in the smoke. Extraction was ugly.",
    "Target was already gone. {name1} and {name2} spent three hours in a dead facility.",
    "{name2} tripped a silent alarm. By the time {name1} noticed, it was too late.",
    "Comms went dark ten minutes in. {name1} and {name2} had to improvise an exit.",
    "The briefing said light resistance. It wasn't. {name2} got {name1} out, but that's all.",
    "{name1} made the call to pull out. {name2} disagreed, but they're both alive.",
  ],
};

// ── Result Screen ──
function showResult(selected) {
  const success = Math.random() < 0.5;
  const pool = success ? NARRATIVES.success : NARRATIVES.failure;
  const template = pool[Math.floor(Math.random() * pool.length)];
  const narrative = template
    .replace(/\{name1\}/g, selected[0].name)
    .replace(/\{name2\}/g, selected[1].name);

  document.getElementById('result-heading').textContent = success ? 'MISSION SUCCESS' : 'MISSION FAILED';
  document.getElementById('result-heading').style.color = success ? '#000' : '#999';
  document.getElementById('result-narrative').textContent = narrative;

  const container = document.getElementById('result-cards');
  container.innerHTML = '';
  selected.forEach(char => container.appendChild(renderCard(char)));

  showScreen('screen-result');
}

// ── New Mission ──
document.getElementById('btn-new-mission').addEventListener('click', () => {
  selectedIndices = [];
  roster = generateRoster();
  renderSelectionScreen();
  updateSelectionUI();
  showScreen('screen-selection');
});

renderSelectionScreen();
  </script>
</body>
</html>
